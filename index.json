[{"categories":["读后感"],"content":"GORM","date":"2024-02-01","objectID":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/","tags":["向上管理"],"title":"《向上管理：如何正确汇报工作》读后感","uri":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["读后感"],"content":"Part 1 正确认识上下级关系 在阅读这一章的过程中，我深感作者为职场中的上下级关系问题提供了独到而实用的见解。 首先，作者强调了上下级关系中的“适应原则”，强调“是你适应上司，不是让上司适应你”。这一观点让我深刻认识到在职场中，成功的关键在于我们作为下属需要更主动地适应上司的沟通方式、工作风格和期望。我开始反思自己在与上司沟通中是否真正关注过对方的偏好和期望，以及在工作中是否始终保持了灵活的态度。关于适应上司的工作风格，作者提到了不同上司可能有不同的工作风格，而下属需要灵活调整以适应这些风格，在以后的工作中需要细致观察，及时调整自己的工作方式以更好地配合上司的工作要求。 作者还特别强调了“永远不要让你的上司感到意外”，强调了及时沟通问题和趋势，以避免事态恶化。这使我认识到在工作中要保持高度的警觉性，及时向上司汇报问题，及时并提前报风险，共同制定解决方案，而不是拖到最后一刻。 在“认识上司的5种角色”这一部分，作者深入剖析了上司的不同角色，包括上级领导、下属的人生导师、组织资源的支配者、权力的使用者和未来的资源和朋友，以及我在不同场景下应该如何更好地与上司合作。这让我更全面地了解了上司在组织中的角色和作用，上司是一个很丰富的角色，而不仅仅是上级领导这一种角色。 最后，对于了解上司对下属的期望，作者强调了这一点对于个人成功的关键性。通过深入沟通、观察和主动了解，我们可以更好地明确上司对我们的期望，并在实际工作中超越这些期望，达到更出色的表现。这使我意识到应该足够主动、充分地了解上司的期望，并在实际工作中用实际行动证明自己的价值。 总的来说，这部分内容给我提供了许多有关上下级关系的实用建议。通过深入思考，我认识到自己在适应上司、灵活沟通、理解上司期望等方面还有很多提升的空间。在未来的职场生涯中，我将更积极地应用这些知识，不断完善自己。 ","date":"2024-02-01","objectID":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/:0:1","tags":["向上管理"],"title":"《向上管理：如何正确汇报工作》读后感","uri":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["读后感"],"content":"Part2 建立和谐的上下级关系 阅读这一部分，我领悟到在职场中如何与上司合作共赢，特别是通过建立和谐的上下级关系。在与上司合作共赢的六大原则中，“互赖原则”引起了我的深刻共鸣。作者明确描述了与上司关系的三个阶段：依赖、独立和互赖。尽管我目前仍处于依赖阶段，但这让我更加全面立体的了解到了和上司关系的多种可能性，以及这段关系将来的发展目标。我了解到在未来的职业生涯中，通过建立互相依赖的关系，我可以更好地与上司合作，实现1+1\u003e2的效果。 其次，将上司视为“最重要的大客户”是一个很有启发性的类比，通过帮助上司取得成功，自己也将获得更多的机会和认可。作者还强调了“得到上司的肯定就是自己的功劳”这一观点，与我的想法很吻合，当上司对你的工作表示肯定时，实际上是在间接表达对你个人能力的认可。 除此之外，我学到了在职场中正确展示自己工作成果的关键技巧。在工作‘五位法中，关于工作定位、到位、补位、站位和换位的原则，这让我明白了在工作中如何正确定位自己，让上司放心，哪里需要做哪里，通过实际行动充分展示自己的工作价值。所有的努力都是值得的，必然会带来自己内核的提升。 最后，在“获得上司信任的5个关键”中，作者强调了通过尊重上司、多劳多得、专攻专业、忠诚奉献以及积极沟通等关键要素，可以赢得上司的信任。这使我认识到在与上司互动中，尊重和信任是相辅相成的，而通过实际行动展现专业能力和忠诚度将是取得信任的有效途径。 ","date":"2024-02-01","objectID":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/:0:2","tags":["向上管理"],"title":"《向上管理：如何正确汇报工作》读后感","uri":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["读后感"],"content":"Part3 如何正确汇报工作 关于如何正确汇报工作，我感受到正确的汇报技巧对于个人的工作成果、努力展示至关重要，正确的汇报是向上级展示工作成果的重要机会。我开始认识到，在每一次大小会议前，需要提前准备，来确保高效沟通，这可以更好地展示自己的工作成果。同时，汇报时要有条理、重主次，可以按照时间顺序、主次顺序等结构。 值得重视的是，汇报工作时应该突出重点。作者提到在汇报中先提出结论，然后再详细阐述的方法。这种方式能够更好地吸引领导的注意力，确保在有限的时间内传达出关键信息。我需要学会更加精炼地表达自己，输出领导重视的内容，使汇报更具有说服力。并且，在沟通时，不能只抛出问题，应该在自己调研后，说出问题和几个解决策略，再让领导定夺。 其次，PART3强调了建立中途反馈机制的重要性。不仅需要在整个工作的前后汇报，在中途及时反馈进展或者反馈风险有助于领导更好地了解工作状态，也可以帮助领导在大局上进行时间规划和事项安排。 最后，PART3提到了把握分寸的原则。尽管在汇报中要详实全面，但我们也应当避免擅自决策，不要替上司作出决定。保持对上司的尊重和理解，是正确汇报的基本准则。有问题多交流多沟通，让领导做决定，而非根据以往惯例擅自作主。 ","date":"2024-02-01","objectID":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/:0:3","tags":["向上管理"],"title":"《向上管理：如何正确汇报工作》读后感","uri":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["读后感"],"content":"总结 通过深入学习这三部分，我不仅更全面地了解了如何建立和谐的上下级关系以及如何正确汇报工作，同时也意识到在实际操作中需要更多地注重细节和沟通技巧。我将积极应用这些知识，不断提升自己的表现，脚踏实地，砥砺前行。 ","date":"2024-02-01","objectID":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/:0:4","tags":["向上管理"],"title":"《向上管理：如何正确汇报工作》读后感","uri":"/8_%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"categories":["Learning"],"content":"GORM","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"MINIO ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:0:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"前端上传OR后端上传 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:1:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"前端上传： 优点： 用户体验： 前端上传能够提供更好的用户体验，用户可以直接在浏览器中选择文件并监控上传进度。 减轻服务器负担： 文件可以直接从用户浏览器上传到对象存储服务，减轻了后端服务器的负担。 断点续传： 前端可以更容易地实现断点续传功能，因为文件直接从用户浏览器上传，中间环节的网络中断也不会影响上传。 缺点： 安全性： 前端上传需要特别注意安全性，因为用户可以直接操作上传的请求，ak sk暴露。 限制： 浏览器对文件大小和类型有一些限制，大文件可能会受到浏览器的限制。 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:1:1","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"安全性解决办法 问题：敏感信息（例如 Access Key 和 Secret Key）可能会暴露给用户。 解决： 使用临时凭证： 不要在前端直接使用永久的 Access Key 和 Secret Key。相反，可以通过后端生成临时凭证，前端使用这些临时凭证进行文件上传。 这可以通过使用 AWS 的临时凭证机制（如 STS）或 MinIO 中的 Policy 来实现。 定期轮换凭证可以减少凭证被滥用的风险。 服务端生成临时凭证 func main(){ minioClient, err := minio.New(endpoint, \u0026minio.Options{ Creds: credentials.NewStaticV4(accessKeyID, secretAccessKey, \"\"), Secure: useSSL, }) // 设置过期时间为1小时 expiry := time.Now().Add(1 * time.Hour) // 生成临时凭证 policy := minio.NewPostPolicy() policy.SetBucket(bucketName) policy.SetKey(objectName) policy.SetExpires(expiry) // 生成临时凭证的URL url, formData, err := minioClient.PresignedPostPolicy(policy) if err != nil { log.Fatalln(err) } fmt.Printf(\"Presigned URL: %s\\n\", url) fmt.Printf(\"Form data: %+v\\n\", formData) } ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:1:2","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"后端上传： 优点： 安全性： 后端上传可以更好地控制和验证文件上传，确保数据的安全性。 文件处理： 后端可以处理大文件的存储、备份、转码等需求。 缺点： 用户体验： 用户体验可能较差，因为文件上传的过程可能需要等待，用户无法直接监控上传进度。 服务器负担： 后端需要处理文件上传的请求，可能对服务器造成一定的负担，特别是在高并发情况下。 复杂性： 后端上传可能需要更复杂的技术和代码，包括文件合并、断点续传的实现等。 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:1:3","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"上传文件到MinIO 如果主要使用 MinIO，并且希望与 MinIO 的特定功能交互，可以选择 minio-go/v7。它专注于 MinIO 的特性和用法，可以更方便地使用 MinIO 特有的功能和选项，例如分片上传。 aws-sdk-go 是 Amazon S3 官方 SDK，支持与 Amazon S3 以及其他 AWS 服务的交互。如果应用可能涉及到多个 AWS 服务，或者在一个混合云环境中操作，可能更倾向于使用 aws-sdk-go。 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:2:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"Minio-go/v7包 使用 minio-go/v7 包进行 MinIO 的上传,使用 minio.New 初始化 MinIO 客户端，然后使用 PutObject 方法将本地文件上传到指定的 MinIO 存储桶（Bucket）和路径（ObjectName）。 import ( \"github.com/minio/minio-go/v7\" \"github.com/minio/minio-go/v7/pkg/credentials\" ) func main() { endpoint := \"your-minio-endpoint\" accessKeyID := \"your-access-key\" secretAccessKey := \"your-secret-key\" useSSL := false minioClient, err := minio.New(endpoint, \u0026minio.Options{ Creds: credentials.NewStaticV4(accessKeyID, secretAccessKey, \"\"), Secure: useSSL, }) if err != nil { log.Fatalln(err) } bucketName := \"your-bucket-name\" objectName := \"path/to/destination/file\" filePath := \"path/to/local/file.txt\" file, err := os.Open(filePath) if err != nil { log.Fatalln(err) } defer file.Close() // 使用 PutObject 上传文件 info, err := minioClient.PutObject(context.TODO(), bucketName, objectName, file, -1, minio.PutObjectOptions{}) if err != nil { log.Fatalln(err) } fmt.Printf(\"Successfully uploaded %s of size %d\\n\", objectName, info.Size) } 如果想分片上传，可以用以下方法代替PutObject 上传文件 func MultipartUpload(){ uploadID, err := minioClient.NewMultipartUpload(context.TODO(), bucketName, objectName, minio.PutObjectOptions{}) if err != nil { log.Fatalln(err) } // 分片大小 partSize := int64(5 * 1024 * 1024) // 5MB // 初始化缓冲区 buffer := make([]byte, partSize) // 上传分片 partNumber := 1 for { n, err := file.Read(buffer) if err != nil \u0026\u0026 n \u003c= 0 { break } _, err = minioClient.PutObjectPart(context.TODO(), bucketName, objectName, uploadID, minio.PartNumber(partNumber), minio.PutObjectPartOptions{ Reader: file, ContentType: \"application/octet-stream\", }) if err != nil { log.Fatalln(err) } partNumber++ } // 完成 Multipart Upload _, err = minioClient.CompleteMultipartUpload(context.TODO(), bucketName, objectName, uploadID, minio.CompleteMultipartUploadOptions{}) if err != nil { log.Fatalln(err) } fmt.Printf(\"Successfully uploaded %s\\n\", objectName) } ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:2:1","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"aws-sdk-go包 import ( \"github.com/aws/aws-sdk-go/aws\" \"github.com/aws/aws-sdk-go/aws/credentials\" \"github.com/aws/aws-sdk-go/aws/session\" \"github.com/aws/aws-sdk-go/service/s3\" ) func main() { accessKey := \"your-access-key\" secretKey := \"your-secret-key\" region := \"your-region\" bucketName := \"your-bucket-name\" filePath := \"path/to/your/file.txt\" // 本地文件路径 objectKey := \"your-s3-object-key\" // S3 对象键（文件名） sess, err := session.NewSession(\u0026aws.Config{ Region: aws.String(region), Credentials: credentials.NewStaticCredentials(accessKey, secretKey, \"\"), }) if err != nil { log.Fatal(err) } svc := s3.New(sess) file, err := os.Open(filePath) if err != nil { log.Fatal(err) } defer file.Close() // 配置上传参数 params := \u0026s3.PutObjectInput{ Bucket: aws.String(bucketName), Key: aws.String(objectKey), Body: file, } // 执行上传操作 resp, err := svc.PutObject(params) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully uploaded file to %s/%s\\n\", bucketName, objectKey) fmt.Printf(\"ETag: %s\\n\", *resp.ETag) } ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:2:2","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"从MinIO下载文件 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:3:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"后端下载 使用 FGetObject 方法从 MinIO 存储桶中下载文件到本地. import ( \"github.com/minio/minio-go/v7\" \"github.com/minio/minio-go/v7/pkg/credentials\" ) func main() { endpoint := \"your-minio-endpoint\" accessKeyID := \"your-access-key\" secretAccessKey := \"your-secret-key\" useSSL := false minioClient, err := minio.New(endpoint, \u0026minio.Options{ Creds: credentials.NewStaticV4(accessKeyID, secretAccessKey, \"\"), Secure: useSSL, }) if err != nil { log.Fatalln(err) } bucketName := \"your-bucket-name\" objectName := \"path/to/source/file\" filePath := \"path/to/local/destination/file.txt\" // 使用 GetObject 下载文件 err = minioClient.FGetObject(context.TODO(), bucketName, objectName, filePath, minio.GetObjectOptions{}) if err != nil { log.Fatalln(err) } fmt.Printf(\"Successfully downloaded %s to %s\\n\", objectName, filePath) } ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:3:1","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"下载文件时返回Presigned URL(预签名URL) 让前端直接对接 MinIO 进行文件下载，可以使用 MinIO 提供的临时授权（Presigned URL）的机制。 Presigned URL 允许你在前端生成一个包含访问权限和有效期限的 URL，通过这个 URL 可以直接下载文件，而不需要将访问密钥（access key）和秘密密钥（secret key）暴露给前端。 minio-go/v7包 import ( \"github.com/minio/minio-go/v7\" \"github.com/minio/minio-go/v7/pkg/credentials\" \"github.com/minio/minio-go/v7/pkg/policy\" ) func main() { endpoint := \"your-minio-endpoint\" accessKeyID := \"your-access-key\" secretAccessKey := \"your-secret-key\" useSSL := false minioClient, err := minio.New(endpoint, \u0026minio.Options{ Creds: credentials.NewStaticV4(accessKeyID, secretAccessKey, \"\"), Secure: useSSL, }) if err != nil { log.Fatalln(err) } bucketName := \"your-bucket-name\" objectName := \"path/to/uploaded/file\" expiry := time.Now().Add(1 * time.Hour) // 生成临时凭证 policy := minio.NewPostPolicy() policy.SetBucket(bucketName) policy.SetKey(objectName) policy.SetExpires(expiry) // 可以设置特定的上传条件，例如文件大小、文件类型等 policy.SetContentLengthRange(1, 1024) // 限制文件大小为1B到1KB之间 // 生成临时凭证的URL url, formData, err := minioClient.PresignedPostPolicy(policy) if err != nil { log.Fatalln(err) } fmt.Printf(\"Presigned URL: %s\\n\", url) fmt.Printf(\"Form data: %+v\\n\", formData) } 如果不需要设置特定的上传条件，例如文件大小、文件类型等，可以直接使用PresignedGetObject() // 生成预签名 URL presignedURL, err := minioClient.PresignedGetObject(\"your-bucket-name\", \"path/to/source/file\", expiry, nil) if err != nil { log.Fatalln(err) } aws-sdk-go包 import ( \"github.com/aws/aws-sdk-go/aws\" \"github.com/aws/aws-sdk-go/aws/session\" \"github.com/aws/aws-sdk-go/service/s3\" ) func main() { sess, err := session.NewSession(\u0026aws.Config{ Region: aws.String(\"your-region\"), }) if err != nil { log.Fatal(err) } s3Client := s3.New(sess) bucket := \"your-s3-bucket\" objectKey := \"path/to/your/file.txt\" expiration := time.Now().Add(1 * time.Hour) // 生成预签名 URL req, _ := s3Client.GetObjectRequest(\u0026s3.GetObjectInput{ Bucket: aws.String(bucket), Key: aws.String(objectKey), // 桶里的文件路径+文件名 }) url, err := req.Presign(expiration) if err != nil { log.Fatal(err) } fmt.Printf(\"Presigned URL: %s\\n\", url) } SFTP SFTP (SSH File Transfer Protocol) 是一种通过安全加密的 SSH 连接进行文件传输的协议。它提供了对文件的安全访问和传输，通过在 SSH 连接上建立一个加密通道，保护了数据的机密性和完整性。 SFTP 既可以在交互式用户界面中使用，也可以在命令行中使用，使用户能够执行文件传输和文件管理操作，就像使用传统的 FTP 协议一样。然而，与 FTP 不同，SFTP 在传输过程中使用 SSH 协议进行加密，因此更加安全。 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:3:2","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"SFTP VS FTP SFTP 具有以下优势： 安全性： SFTP 使用 SSH 连接，通过加密通道传输数据，提供更高级别的安全性，防止数据在传输过程中被窃听或篡改。 端到端加密： SFTP 提供端到端的加密，包括身份验证和数据传输，确保数据的完整性和机密性。 单一连接： SFTP 使用单一的连接进行文件传输和管理，而不像 FTP 那样需要多个连接（控制连接和数据连接）。 支持用户身份验证： SFTP 通常通过用户名和密码进行身份验证，也支持其他身份验证方法，如公钥、证书等。 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:4:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"建立SFTP连接 import ( \"golang.org/x/crypto/ssh\" \"golang.org/x/crypto/ssh/agent\" ) func main() { sftpServer := \"your-sftp-server\" sftpPort := 22 // 用户名和密码（可以使用其他身份验证方法，如密钥） username := \"your-username\" password := \"your-password\" sshConfig := \u0026ssh.ClientConfig{ User: username, Auth: []ssh.AuthMethod{ ssh.Password(password), }, HostKeyCallback: ssh.InsecureIgnoreHostKey(), // 不验证服务器的 HostKey } // 建立 SSH 连接 conn, err := ssh.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", sftpServer, sftpPort), sshConfig) if err != nil { log.Fatalf(\"Failed to dial: %v\", err) } defer conn.Close() // 建立 SFTP 客户端 client, err := sftp.NewClient(conn) if err != nil { log.Fatalf(\"Failed to create SFTP client: %v\", err) } defer client.Close() } 为了安全起见，应该使用密钥而不是密码进行身份验证，并且在生产环境中，应该验证服务器的 HostKey。 ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:5:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"上传和下载文件 // 上传文件 func uploadFile(client *sftp.Client, localPath, remotePath string) { localFile, err := os.Open(localPath) if err != nil { log.Fatalf(\"Failed to open local file: %v\", err) } defer localFile.Close() remoteFile, err := client.Create(remotePath) if err != nil { log.Fatalf(\"Failed to create remote file: %v\", err) } defer remoteFile.Close() _, err = localFile.WriteTo(remoteFile) if err != nil { log.Fatalf(\"Failed to upload file: %v\", err) } fmt.Printf(\"File '%s' uploaded to '%s'\\n\", localPath, remotePath) } // 下载文件 func downloadFile(client *sftp.Client, remotePath, localPath string) { remoteFile, err := client.Open(remotePath) if err != nil { log.Fatalf(\"Failed to open remote file: %v\", err) } defer remoteFile.Close() localFile, err := os.Create(localPath) if err != nil { log.Fatalf(\"Failed to create local file: %v\", err) } defer localFile.Close() _, err = remoteFile.WriteTo(localFile) if err != nil { log.Fatalf(\"Failed to download file: %v\", err) } fmt.Printf(\"File '%s' downloaded to '%s'\\n\", remotePath, localPath) } ","date":"2024-01-18","objectID":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/:6:0","tags":["MinIO","SFTP"],"title":"文件上传与下载","uri":"/7_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"},{"categories":["Learning"],"content":"GORM","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"Go中如何压缩文件 ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:0:0","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"zip zlib gzip 的区别 总的来说，ZIP适用于多文件和目录的归档，ZLIB适用于轻量级的数据压缩，而GZIP适用于单个文件的压缩。 如果需要跨平台支持并涉及多文件归档，ZIP可能是更好的选择；如果只是需要对单个文件或数据进行压缩，ZLIB或GZIP可能更适合。 ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:1:0","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"ZIP 设计目标：ZIP是一种通用的压缩和归档格式，旨在提供对多个文件和目录的支持。 压缩算法：使用DEFLATE算法进行数据压缩。 使用场景：适用于需要在不同操作系统之间进行文件传输或存档的场景，因为ZIP格式是跨平台支持的。 ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:1:1","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"ZLIB 设计目标：ZLIB是一个用于数据压缩和解压缩的库，它并不直接提供归档功能，而是专注于提供一种通用的压缩算法。 压缩算法：使用DEFLATE算法，与ZIP相同。 使用场景：适用于需要在程序中对单个文件或数据进行轻量级压缩和解压缩的场景，而不涉及归档。 ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:1:2","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"GZIP 设计目标：GZIP是一种常用的压缩和归档格式，通常用于对单个文件进行压缩。 压缩算法：也使用DEFLATE算法，但与ZIP格式略有不同的头部和尾部格式。 使用场景：适用于需要在文件系统中存储或传输单个文件的场景，因为GZIP格式在UNIX/Linux环境中广泛支持 ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:1:3","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"在Go中如何应用 ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:2:0","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"ZIP（archive/zip） archive/zip包主要用于创建和解析ZIP格式的归档文件。使用archive/zip包的Create函数创建一个zip.Writer，然后添加文件并进行压缩。 缺点：ZIP格式是通用的归档格式，但相对于一些其他格式，它可能在某些情况下产生较大的文件。 import ( \"archive/zip\" \"os\" ) func main() { outputFile, _ := os.Create(\"output.zip\") defer outputFile.Close() zipWriter := zip.NewWriter(outputFile) defer zipWriter.Close() // 添加文件到ZIP文件中 fileToZip, _ := os.Open(\"file.txt\") defer fileToZip.Close() fileInfo, _ := fileToZip.Stat() zipHeader, _ := zip.FileInfoHeader(fileInfo) fileInZip, _ := zipWriter.CreateHeader(zipHeader) // 将文件内容拷贝到ZIP文件中 io.Copy(fileInZip, fileToZip) } ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:2:1","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"ZLIB（compress/zlib）： compress/zlib包提供了对ZLIB格式的压缩和解压缩支持，适用于需要在程序中进行轻量级压缩和解压缩操作的场景。 使用compress/zlib包的NewWriter函数创建一个zlib.Writer，然后将数据写入以进行压缩。 缺点：ZLIB格式通常不用于直接创建归档文件，而是用于对单个文件或数据进行压缩。 import ( \"compress/zlib\" \"os\" ) func main() { outputFile, _ := os.Create(\"output.zlib\") defer outputFile.Close() zlibWriter := zlib.NewWriter(outputFile) defer zlibWriter.Close() // 将数据写入以进行压缩 dataToCompress := []byte(\"Hello, world!\") zlibWriter.Write(dataToCompress) } ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:2:2","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"GZIP（compress/gzip）： compress/gzip包提供了对GZIP格式的压缩和解压缩支持，适用于需要在文件系统中存储或传输数据的场景，因为GZIP格式是广泛支持的。 使用compress/gzip包的NewWriter函数创建一个gzip.Writer，然后将数据写入以进行压缩。 缺点：GZIP格式相对于一些其他格式可能产生较大的文件，但通常比ZIP格式更有效。 import ( \"compress/gzip\" \"os\" ) func main() { outputFile, _ := os.Create(\"output.gz\") defer outputFile.Close() gzipWriter := gzip.NewWriter(outputFile) defer gzipWriter.Close() // 将数据写入以进行压缩 dataToCompress := []byte(\"Hello, world!\") gzipWriter.Write(dataToCompress) } ","date":"2024-01-11","objectID":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/:2:3","tags":["Zip"],"title":"Go语言学习之压缩文件","uri":"/6_%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/"},{"categories":["Learning"],"content":"GORM","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"Kubernetes体系架构 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:0:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"什么是Kubernetes Kubernetes（K8s）是一个开源的容器编排平台，旨在简化和自动化容器化应用程序的部署、扩展和管理。它提供了一个强大的工具集，帮助我们能够更轻松地构建和运行容器化应用。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:1:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"核心理念 容器化： Kubernetes利用容器技术（如Docker）将应用及其所有依赖项打包成一个可移植的镜像，确保在任何环境中都能一致运行。 自动化： Kubernetes旨在自动化应用的部署、伸缩、升级和故障恢复等操作，减轻开发人员和运维人员的负担。 弹性和可伸缩： Kubernetes能够根据负载的变化自动调整应用程序的规模，确保系统具有弹性和高可用性。 声明式配置： 用户通过声明式配置文件描述应用程序的期望状态，Kubernetes负责调整实际状态以匹配期望状态。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:1:1","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"关键特性 容器编排： Kubernetes是一个容器编排平台，负责管理和编排多个容器实例，确保它们协同工作。 自动伸缩： Kubernetes能够根据负载自动调整应用程序的规模，提高资源利用率。 服务发现和负载均衡： Kubernetes提供了内置的服务发现和负载均衡机制，确保应用程序能够可靠地相互通信。 持久化存储： Kubernetes支持持久化存储，使应用程序可以在容器之间共享数据。 声明式配置： 用户通过YAML文件声明应用程序的配置和期望状态，Kubernetes负责实现这些声明。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:1:2","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"Kubernetes集群 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:2:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"集群的架构体系 Kubernetes集群的架构体系主要包括Master节点和Worker节点。 Master节点： 是集群的控制中心，负责管理和监控整个集群。主要包括以下核心组件： API Server： 提供Kubernetes API，是集群通信的接口。 Controller Manager： 监视集群资源，确保实际状态与期望状态一致。 Scheduler： 负责Pod的调度，决定将Pod调度到哪个Worker节点。 etcd： 分布式键值存储，持久化存储集群的配置数据和状态信息。 Node节点： 是集群中真正运行应用程序容器的节点。主要包括以下核心组件： Kubelet： 与Master节点通信，管理Pod的生命周期。 容器运行时： 负责运行和管理容器。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:2:1","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"Kubernetes的核心组件 Kubernetes的核心组件是Master节点上的一组关键服务，它们共同协作以管理集群中的容器化应用。这些核心组件包括： API Server： 提供Kubernetes API，是集群通信的接口。 Controller Manager： 监视集群中的资源对象，确保实际状态与期望状态一致。 Scheduler： 负责将新创建的Pod调度到集群中的某个Worker节点上。 kubelet： 管理node节点上运行的pod，并与master节点上的API Server进行交互。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:2:2","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"Kubernetes的对象 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:3:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"对象的管理 在Kubernetes中，通过API Server进行对象的管理，用户可以使用配置文件（JSON或YAML格式）来定义和部署对象。 简单的YAML部署示例： apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 Notes: 创建了一个名为nginx-deployment的Deployment，由.metadata.name字段指定。这个名称将成为后续创建的ReplicaSets和Pods的基础。 Deployment创建了一个ReplicaSet，该ReplicaSet创建了三个复制的Pod，由.spec.replicas字段指示。 .spec.selector字段定义了创建的ReplicaSet如何找到要管理的Pod。在这种情况下，选择在Pod模板中定义的标签（app: nginx）。但是，只要Pod模板本身满足规则，就可以使用更复杂的选择规则。 template字段包含以下子字段： Pods使用.metadata.labels字段标记为app: nginx。 Pod模板的规范，或.template.spec字段，表示Pods运行一个名为nginx的容器，该容器使用Docker Hub上的nginx镜像，版本为1.14.2。 创建一个容器并命名为nginx，使用.spec.template.spec.containers[0].name字段。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:3:1","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"对象与命名空间 Kubernetes使用命名空间（Namespace）来隔离集群中的不同资源，以避免命名冲突和提供更好的资源管理。在部署完Kubernetes集群后，系统会自动创建一些常见的命名空间，包括： default： 默认的命名空间，如果未指定命名空间，则资源将被创建在default命名空间中。 kube-system： 用于存储Kubernetes系统组件的命名空间，如kube-controller-manager、kube-scheduler等。用户不该使用。 kube-public： 公开的属性，用于存储集群中所有节点都能访问的资源。 kube-node-lease： 与所有node节点上的对象相关联，检测node节点状态。 Kubernetes中的最小可部署对象Pod Pod代表集群中正在运行的一个进程，是集群中的一个应用实例，由一个或多个容器组成。 单容器pod：pod中只运行一个容器，通过pod来管理这个容器。 多容器pod：pod中有多个容器一起协同工作，K8s调度器保证所有容器都运行在同一物理主机/虚机上，so容器间可以资源共享。 通过yaml文件可以描述一个pod apiVersion: v1 #指定api版本，此值必须在kubectl apiversion中 kind: Pod #指定创建资源的角色/类型 metadata: #资源的元数据/属性 name: first-pod #资源的名字，在同一个namespace中必须唯一 labels: #设定资源的标签 k8s-app: apache version: v1 kubernetes.io/cluster-service: \"true\" annotations: #自定义注解列表 - name: String #自定义注解名字 spec: #specification of the resource content 指定该资源的内容 restartPolicy: Always #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器 nodeSelector: #节点选择，先给主机打标签kubectl label nodes kube-node1 zone=node1 zone: node1 containers: - name: busybox-container #容器的名字 image: busybox:apache #容器使用的镜像地址 imagePullPolicy: Never #三个选择Always、Never、IfNotPresent，每次启动时检查和更新（从registery）images的策略， # Always，每次都检查 # Never，每次都不检查（不管本地是否有） # IfNotPresent，如果本地有就不检查，如果没有就拉取 command: ['sh'] #启动容器的运行命令，将覆盖容器中的Entrypoint,对应Dockefile中的ENTRYPOINT args: [\"$(str)\"] #启动容器的命令参数，对应Dockerfile中CMD参数 env: #指定容器中的环境变量 - name: str #变量的名字 value: \"/etc/run.sh\" #变量的值 resources: #资源管理 requests: #容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行 cpu: 0.1 #CPU资源（核数），两种方式，浮点数或者是整数+m，0.1=100m，最少值为0.001核（1m） memory: 32Mi #内存使用量 limits: #资源限制 cpu: 0.5 memory: 32Mi ports: - containerPort: 80 #容器开发对外的端口 name: httpd #名称 protocol: TCP livenessProbe: #pod内容器健康检查的设置 httpGet: #通过httpget检查健康，返回200-399之间，则认为容器正常 path: / #URI地址 port: 80 #host: 127.0.0.1 #主机地址 scheme: HTTP initialDelaySeconds: 180 #表明第一次检测在容器启动后多长时间后开始 timeoutSeconds: 5 #检测的超时时间 periodSeconds: 15 #检查间隔时间 lifecycle: #生命周期管理 postStart: #容器运行之前运行的任务 exec: command: - 'sh' - 'yum upgrade -y' preStop: #容器关闭之前运行的任务 exec: command: ['service httpd stop'] volumeMounts: - name: volume #挂载设备的名字，与volumes[*].name 需要对应 mountPath: /data #挂载到容器的某个路径下 readOnly: True volumes: #定义一组挂载设备 - name: volume #定义一个挂载设备的名字 #meptyDir: {} hostPath: path: /opt #挂载设备类型为hostPath，路径为宿主机下的/opt,这里设备类型支持很多种 Notes: labels: 资源的标签是一对KV，对用户而言非常有意义的，但对K8S本身而言没有直接意义的。Label可以在创建对象时指定，也可以在后期修改，每个对象可以拥有多个标签，但key值必须是唯一的。通过Label进行对象弱关联，灵活地分类和选择不同服务或业务，让用户根据自己特定的组织结构以松耦合方式进行服务部署。 resources 资源管理: 默认情况下，kubernetes不会限制pod等资源对象使用系统资源，单个pod或者容器可以无限制使用系统资源。kubernetes的资源管理分为资源请求（request）和资源限制（limit），资源请求能够保证Pod有足够的资源来运行，而资源限制则是防止某个Pod无限制地使用资源，导致其他Pod崩溃。 应用程序健康检查: 分为livenessProbe和readinessProbe，两者相似。livenessProbe在服务运行过程中检查应用程序是否运行正常，不正常将杀掉进程；而readnessProbe是用于检测应用程序启动完成后是否准备好对外提供服务，不正常继续检测，直到返回成功为止。 volumeMounts： 在K8S中，当Pod重建的时候，数据是会丢失的，K8S也是通过数据卷挂载来提供Pod数据的持久化的。K8S数据卷是对Docker数据卷的扩展，K8S数据卷是Pod级别的，可以用来实现Pod中容器的文件共享。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:3:2","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"pod中的容器 基础容器：维护整个pod的网络空间 初始化容器：需要在\"spec\"中添加\"initContainers\"字段。晚于基础容器运行，早于业务容器运行。一个pod可以有多个初始化容器，可以提前安装在业务容器中要使用的工具，或运行一些初始化脚本。 临时容器：在pod中临时运行，以完成用户发起的操作（故障排查、性能诊断），最大用途是调试其他容器。 业务容器：实际运行应用的容器。 通过 Service 访问 Pod Service为应用提供统一的访问地址。它提供了一个稳定的网络端点，以便其他应用或服务可以通过该端点与 Pod 进行通信。 对集群内部，它不断跟踪pod的变化，更新endpoint中对应pod的对象，提供了ip不断变化的pod的服务发现机制； 对集群外部，他类似负载均衡器，可以在集群外部对pod进行访问。在Kubernetes中，Pod的IP地址和service的ClusterIP仅可以在集群网络内部做用，对于集群外的应用是不可见的。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:4:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"定义service apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 这里定义了一个service，它通过标签选择器 app: my-app 与具有相同标签的 Pod 关联。Service 在端口 80 上监听请求，并将流量转发到 Pod 的端口 8080。 检查service状态: kubectl get services ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:5:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"Service的类型 ClusterIP 默认类型，将 Service 暴露在集群内部，集群内部其他 Pod 可以通过 ClusterIP 访问。 NodePort 在每个节点上开放一个静态端口，使得外部可以通过节点的 IP 和该端口访问 Service。 缺点： 因为每个端口只能是一种服务，端口范围只能是 30000-32767。当有几十上百的服务在集群中运行时，NodePort的端口管理就是个灾难。 LoadBalancer 通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置Servic的场景。受限于云平台，且通常在云平台部署LoadBalancer还需要额外的费用。 ExternalName 将 Service 映射到外部服务的 DNS 名称。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:6:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"集群外部请求访问集群内应用的最佳方式 — Ingress 只需一个或者少量的公网IP和LB，即可同时将多个HTTP服务暴露到外网，七层反向代理。可以简单理解为service的service，它其实就是一组基于域名和URL路径，把用户的请求转发到一个或多个service的规则。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:6:1","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Learning"],"content":"Service的使用 a. 集群内部访问pod kubectl exec -it \u003cpod-name\u003e -- /bin/sh curl \u003cservice-name\u003e b. 外部访问（NodePort） 在浏览器中访问节点的 IP 地址和指定的 NodePort。 常用命令 第三部分：常用指令 获取Pod信息 kubectl -n ccos-ops-app get pod kubectl -n ccos-ops-app get pod | grep jobm kubectl -n ccos-ops-app get pod -owide | grep jobm 获取特定部署的 Pod 信息 kubectl -n ccos-ops-app get deploy jobm 在容器内执行特定命令 kubectl exec -n ccos-ops-app -it jobm-5b6fdbd5d7-55dqs -- /bin/sh kubectl exec cmdb-fafsf-kfasf -n ccos-ops-region -it -- bash -\u003e curl 删除 Pod kubectl delete pod \u003cpod-name\u003e -n \u003cnamespace\u003e kubectl delete pod \u003cpod-name\u003e -n \u003cnamespace\u003e --force 查看日志 kubectl -n ccos-ops-app logs -f \u003cpod-name\u003e --tail=300 编辑pod kubectl edit pod \u003cpod-name\u003e -n \u003cnamespace\u003e 修改服务 kubectl -n ccos-mysql edit svc ccos-mysql type 从 ClusterIP 改成 NodePort kubectl get svc -n ccos-mysql kubectl expose pod -n ccos-clickhouse ck-logging-0-0-0 kubectl -n ccos-clickhouse edit svc ck-logging-0-0-0 kubectl -n ccos-clickhouse get svc 操作Cronjob kubectl apply -f 0000_90_jobm_041_cronjob.yaml kubectl -n ccos-ops-app get cronjob kubectl -n ccos-ops-app edit cronjob kubectl delete cronjob cronjob-name kubectl get job 登录到节点进行 sudo 操作： ssh -i id_rsa ccadmin@ 结语 通过阅读《Docker+Kubernetes容器实战派》这本书，让我深入了解了这个强大的容器编排系统，对于容器化应用的部署和管理有了更深层次的理解。 通过每一章节的学习，我逐渐掌握了 Kubernetes 的基本概念，了解了它的体系架构、以及各种对象的管理方式。学会了如何部署 Kubernetes 集群，以及如何通过 Service 访问 Pod，同时也涉及了持久化存储等重要主题。 当然，这只是一个开始，我意识到还有很多高级概念和特性等待我深入研究，比如安全认证、自动化部署、集成与运维管理等，未来我还会继续追求更深入的知识。 ","date":"2024-01-04","objectID":"/5_k8s%E5%9F%BA%E7%A1%80/:7:0","tags":["k8s"],"title":"Kubernetes基础","uri":"/5_k8s%E5%9F%BA%E7%A1%80/"},{"categories":["Note"],"content":"笔记","date":"2023-11-05","objectID":"/note/","tags":["Notes"],"title":"Notes","uri":"/note/"},{"categories":["Note"],"content":"笔记 GORM文件初始化 go mod init module_name go mod tidy go mod vendor 去掉.idea git rm -rf .idea --cached 去掉.DS touch ~/.gitignore_global open ~/.gitignore_global 在 .gitignore_global文件中输入 *~ .DS_Store ._.DS_Store ._* 可以去掉.DS git config --global core.excludesfile ~/.gitignore_global ","date":"2023-11-05","objectID":"/note/:1:0","tags":["Notes"],"title":"Notes","uri":"/note/"},{"categories":["Note"],"content":"待学习： 跑GO和GORM的案例 学习文档： https://www.w3cschool.cn/git/ https://www.w3cschool.cn/sql/ https://www.w3cschool.cn/golang_gin/ https://www.w3cschool.cn/linux/ https://www.w3cschool.cn/kubernetes/ ","date":"2023-11-05","objectID":"/note/:2:0","tags":["Notes"],"title":"Notes","uri":"/note/"},{"categories":["Learning"],"content":"Gin","date":"2023-11-05","objectID":"/gin/","tags":["Gin"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"路由 import ( \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() user := r.Group(\"/user\") user.GET(\"/index\", func(c *gin.Context) {}) user.POST(\"/login\", func(c *gin.Context) {}) r.Run() } ","date":"2023-11-05","objectID":"/gin/:0:1","tags":["Gin"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"获取参数 Query方式 获取URL中？后面所携带的参数，例如/name=admin\u0026pwd=123456 r.GET(\"/\", func(c *gin.Context) { name := c.Query(\"name\") pwd := c.Query(\"pwd\") c.JSON(http.StatusOK, gin.H{ \"name\": name, \"pwd\": pwd, }) }) Form方式 r.POST(\"/\", func(c *gin.Context) { username := c.PostForm(\"username\") //对应h5表单中的name字段 password := c.PostForm(\"password\") c.HTML(http.StatusOK, \"index.html\", gin.H{ \"username\": username, \"password\": password, }) }) Path方式 通过URL路径传递，例如/user/admin r.GET(\"/user/:username\", func(c *gin.Context) { username := c.Param(\"username\") c.JSON(http.StatusOK, gin.H{ \"username\": username, }) }) Body router.POST(\"/post-data\", func(c *gin.Context) { var inputData struct { Name string `json:\"name\"` Email string `json:\"email\"` } if err := c.ShouldBindJSON(\u0026inputData); err != nil { c.JSON(400, gin.H{\"error\": err.Error()}) return } name := inputData.Name email := inputData.Email c.JSON(200, gin.H{\"name\": name, \"email\": email}) }) ","date":"2023-11-05","objectID":"/gin/:0:2","tags":["Gin"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"HTML渲染 使用LoadHTMLGlob() 或者 LoadHTMLFiles()来渲染HTML模板 func main() { r := gin.Default() r.LoadHTMLGlob(\"./templates/*\") r.GET(\"/demo\",func(c *gin.Context) { c.HTML(http.StatusOK,\"index.html\",gin.H{ \"name\":\"admin\", \"pwd\":\"123456\", }) }) r.Run() } 需要创建一个存放模板文件的templates文件夹，然后在其内部写入一个index.html。 ","date":"2023-11-05","objectID":"/gin/:0:3","tags":["Gin"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"Tips api设计时注重实际需求，比如用户登陆用手机号不用id。 CURD中 query update delete 都可以把id放进url里不放form里 使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。 指针函数 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodPost, relativePath, handlers) } // HandlerFunc defines the handler used by gin middleware as return value. type HandlerFunc func(*Context) func Run(router *gin.Engine) { user := router.Group(\"app/user\") user.POST(\"/register\", buildPolicyHolder) router.Run() } 存储用户密码 加密方式: 密码 + 盐(一串随机数) + 用户信息 + Hash (Hash Table自己创建) 数据库存储用户密码和盐。 ","date":"2023-11-05","objectID":"/gin/:0:4","tags":["Gin"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"OOP","date":"2023-10-30","objectID":"/oop_post/","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"Object Oriented Programming 面向对象程序设计 ","date":"2023-10-30","objectID":"/oop_post/:0:0","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"多态 Golang是一种静态类型的编程语言，没有像传统面向对象语言那样提供显式的多态特性。然而，Golang通过接口的使用可以实现多态的效果。 What 多态是面向对象编程中的一个重要概念，它允许使用不同的对象来执行相同的操作，从而实现了代码的灵活性和可扩展性。简单来说，多态意味着一个方法可以根据接收到的不同对象的类型来执行不同的行为。 Why 使用多态可以使代码更加灵活和可扩展。通过多态，我们可以在不改变原有代码的基础上，新增或修改对象的行为。这种灵活性使得代码更易于维护和扩展，并且提高了代码的可复用性。 How 在Golang中，多态可以通过接口来实现。接口是一种抽象类型，它定义了一组方法的集合。如果一个对象实现了接口所定义的所有方法，那么该对象就可以被视为该接口类型的实例。通过这种方式，我们可以将不同类型的对象视为相同的接口类型，从而实现多态的效果。 package main import \"fmt\" type Shape interface { Area() float64 } type Rectangle struct { width float64 height float64 } func (r Rectangle) Area() float64 { return r.width * r.height } type Circle struct { radius float64 } func (c Circle) Area() float64 { return 3.14 * c.radius * c.radius } func GetArea(s Shape) float64 { return s.Area() } func main() { r := Rectangle{width: 5, height: 3} c := Circle{radius: 4} fmt.Println(\"Rectangle area:\", GetArea(r)) fmt.Println(\"Circle area:\", GetArea(c)) } ","date":"2023-10-30","objectID":"/oop_post/:1:0","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"封装 封装是面向对象编程中的一种重要概念，它指的是将数据和对数据的操作封装在一起，形成一个独立的单元。在Golang中，封装通过访问控制来实现，即使用大小写字母来决定成员的可见性。 What 封装是将数据和对数据的操作封装在一起，形成一个单独的实体。在Golang中，封装通过使用大小写字母来决定成员的可见性。小写字母开头的标识符为私有成员，只能在当前包内访问；大写字母开头的标识符为公共成员，可以在任何包中访问。 Why 封装的主要目的是将数据隐藏起来，防止外部直接访问和修改。通过封装，可以实现对数据的保护，避免数据被意外修改或滥用。同时，封装还可以隐藏实现细节，提高代码的安全性和可维护性。 How 可以通过结构体和方法来实现封装。结构体是一种自定义数据类型，可以将不同类型的数据封装在一起。方法是与结构体关联的函数，用于对结构体的操作和行为进行封装。 package main import ( \"fmt\" ) type Person struct { name string age int gender string } func (p *Person) SetName(name string) { p.name = name } func (p *Person) GetName() string { return p.name } func main() { p := Person{ name: \"Alice\", age: 20, gender: \"Female\", } fmt.Println(p.GetName()) // 输出：Alice p.SetName(\"Bob\") fmt.Println(p.GetName()) // 输出：Bob } ","date":"2023-10-30","objectID":"/oop_post/:2:0","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"继承 ","date":"2023-10-30","objectID":"/oop_post/:3:0","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"why 继承的特点是可以在在原来的类的属性基础上增加新的属性。 把通用型的代码同一编写在一个基类中 ，在子类中添加新的属性。 可以重用前期项目中经过验证和检查的bug少的类，不会破坏原有的代码架构。 ","date":"2023-10-30","objectID":"/oop_post/:3:1","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"继承规则 在派生类没有改写基类的成员方法时，相应的成员方法被继承。 派生类可以直接调用基类的成员方法，譬如基类有个成员方法为Base.Func()，那么Derived.Func()等同于Derived.Base.Func() 如果派生类的成员方法名与基类的成员方法名相同，那么基类方法将被覆盖或叫隐藏。比如基类和派生类都有成员方法Func()，那么Derived.Func()将只能调用派生类的Func()方法，如果要调用基类版本，可以通过Derived.Base.Func()来调用。 package main import \"fmt\" type Base struct { BaseName string } func (b *Base) PrintName() { fmt.Println(b.BaseName) } type Derived struct { DerivedName string Base } func (d *Derived) PrintName() { fmt.Println(d.DerivedName) } func main() { d := \u0026Derived{} d.BaseName = \"BaseStruct\" d.DerivedName = \"DerivedStruct\" d.Base.PrintName() // BaseStruct d.PrintName() // DerivedStruct } ","date":"2023-10-30","objectID":"/oop_post/:3:2","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"总结 在 go 语言中，type name struct{} 结构体，相当于其他语言中的 class 类的概念。 在其他语言中，方法是直接写在在 类 里面的，而在 go 语言中，我们对于该结构体，如果存在方法，是以 func (结构体名) 方法名{}，即 func(c Cat) sleep{} 的方式来声明方法。 ","date":"2023-10-30","objectID":"/oop_post/:4:0","tags":["OOP"],"title":"GO中的面向对象编程","uri":"/oop_post/"},{"categories":["Learning"],"content":"GORM","date":"2023-10-22","objectID":"/first_post/","tags":["GORM"],"title":"GORM学习总结","uri":"/first_post/"},{"categories":["Learning"],"content":"ORM Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说，定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。 GORM（Go Object Relational Mapping）用于将Go应用程序中的结构体与关系型数据库之间进行映射，从而简化了数据库操作。它提供了一种便捷的方式来执行常见的数据库操作，如创建、读取、更新和删除（CRUD），以及复杂的查询和关联操作。 声明模型 type User struct { ID uint Name string Age int } 使用声明模型创建数据库表 db.AutoMigrate(\u0026User{}) 如果模型是动态模型，可使用原生SQL创建数据库表。 db.Exec() CREATE 传入数据的指针 newUser := User{Name: \"John\", Age: 30} db.Create(\u0026newUser) 根据Map创建 db.Model(\u0026User{}).Create(map[string]interface{}{ \"Name\": \"jinzhu\", \"Age\": 18, }) db.Model(\u0026User{}).Create([]map[string]interface{}{ {\"Name\": \"jinzhu_1\", \"Age\": 18}, {\"Name\": \"jinzhu_2\", \"Age\": 20}, }) QUERY 通过主键提取记录 var user User db.First(\u0026user, 1) 提取所有记录 var users []User db.Find(\u0026users) 按条件查询 db.Where(\"Age \u003e ?\", 25).Find(\u0026users) db.Where(\"Name LIKE ?\", \"%John%\").Find(\u0026users) 查询名字中包含John的用户 UPDATE db.Model(\u0026user).Update(\"Age\", 31) 更新多列 db.Model(\u0026user).Updates(User{Name: \"hello\", Age: 18, Active: false}) db.Model(\u0026user).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) 使用 struct 更新时，GORM 只更新非零字段。需要使用 map 来更新，或使用 Select 来指定要更新的字段。 DELETE db.Delete(\u0026user) db.Where(\"name = ?\", \"jinzhu\").Delete(\u0026user) 根据主键批量删除 db.Delete(\u0026users, []int{1,2,3}) Sorting \u0026 Limiting db.Order(\"Age desc\").Limit(10).Find(\u0026users) 关联 type User struct { gorm.Model Name string CompanyRefer int Company Company `gorm:\"foreignKey:CompanyRefer;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type Company struct { ID int Name string } Transactions tx := db.Begin() if err := tx.Create(\u0026User{Name: \"Alice\"}).Error; err != nil { tx.Rollback() } else { tx.Commit() } 使用tx而不能使用db，否则无效。 Tips 初始化指针，防止指针为空。 var city = \u0026entity.City{} 检查是否存在、不存在则创建，要考虑全面。 if errors.Is(result.Error, gorm.ErrRecordNotFound) || city == nil { tx := data.DB.Create(\u0026jsonCity) } ","date":"2023-10-22","objectID":"/first_post/:0:0","tags":["GORM"],"title":"GORM学习总结","uri":"/first_post/"}]