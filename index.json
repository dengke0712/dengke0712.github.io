[{"categories":["Note"],"content":"笔记","date":"2023-11-05","objectID":"/note/","tags":["Hugo"],"title":"Notes","uri":"/note/"},{"categories":["Note"],"content":"笔记 GORM文件初始化 go mod init module_name go mod tidy go mod vendor 去掉.idea git rm -rf .idea --cached 去掉.DS touch ~/.gitignore_global open ~/.gitignore_global 在 .gitignore_global文件中输入 *~ .DS_Store ._.DS_Store ._* 可以去掉.DS git config --global core.excludesfile ~/.gitignore_global ","date":"2023-11-05","objectID":"/note/:1:0","tags":["Hugo"],"title":"Notes","uri":"/note/"},{"categories":["Learning"],"content":"Gin","date":"2023-11-05","objectID":"/gin/","tags":["Hugo"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"路由 import ( \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() user := r.Group(\"/user\") user.GET(\"/index\", func(c *gin.Context) {}) user.POST(\"/login\", func(c *gin.Context) {}) r.Run() } ","date":"2023-11-05","objectID":"/gin/:0:1","tags":["Hugo"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"获取参数 Query方式 获取URL中？后面所携带的参数，例如/name=admin\u0026pwd=123456 r.GET(\"/\", func(c *gin.Context) { name := c.Query(\"name\") pwd := c.Query(\"pwd\") c.JSON(http.StatusOK, gin.H{ \"name\": name, \"pwd\": pwd, }) }) Form方式 r.POST(\"/\", func(c *gin.Context) { username := c.PostForm(\"username\") //对应h5表单中的name字段 password := c.PostForm(\"password\") c.HTML(http.StatusOK, \"index.html\", gin.H{ \"username\": username, \"password\": password, }) }) Path方式 通过URL路径传递，例如/user/admin r.GET(\"/user/:username\", func(c *gin.Context) { username := c.Param(\"username\") c.JSON(http.StatusOK, gin.H{ \"username\": username, }) }) Body router.POST(\"/post-data\", func(c *gin.Context) { var inputData struct { Name string `json:\"name\"` Email string `json:\"email\"` } if err := c.ShouldBindJSON(\u0026inputData); err != nil { c.JSON(400, gin.H{\"error\": err.Error()}) return } name := inputData.Name email := inputData.Email c.JSON(200, gin.H{\"name\": name, \"email\": email}) }) ","date":"2023-11-05","objectID":"/gin/:0:2","tags":["Hugo"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"HTML渲染 使用LoadHTMLGlob() 或者 LoadHTMLFiles()来渲染HTML模板 func main() { r := gin.Default() r.LoadHTMLGlob(\"./templates/*\") r.GET(\"/demo\",func(c *gin.Context) { c.HTML(http.StatusOK,\"index.html\",gin.H{ \"name\":\"admin\", \"pwd\":\"123456\", }) }) r.Run() } 需要创建一个存放模板文件的templates文件夹，然后在其内部写入一个index.html。 ","date":"2023-11-05","objectID":"/gin/:0:3","tags":["Hugo"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"Tips api设计时注重实际需求，比如用户登陆用手机号不用id。 CURD中 query update delete 都可以把id放进url里不放form里 使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。 指针函数 func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodPost, relativePath, handlers) } // HandlerFunc defines the handler used by gin middleware as return value. type HandlerFunc func(*Context) func Run(router *gin.Engine) { user := router.Group(\"app/user\") user.POST(\"/register\", buildPolicyHolder) router.Run() } 存储用户密码 加密方式: 密码 + 盐(一串随机数) + 用户信息 + Hash (Hash Table自己创建) 数据库存储用户密码和盐。 ","date":"2023-11-05","objectID":"/gin/:0:4","tags":["Hugo"],"title":"Gin学习笔记","uri":"/gin/"},{"categories":["Learning"],"content":"OOP","date":"2023-10-30","objectID":"/oop_post/","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"Object Oriented Programming 面向对象程序设计 ","date":"2023-10-30","objectID":"/oop_post/:0:0","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"多态 Golang是一种静态类型的编程语言，没有像传统面向对象语言那样提供显式的多态特性。然而，Golang通过接口的使用可以实现多态的效果。 What 多态是面向对象编程中的一个重要概念，它允许使用不同的对象来执行相同的操作，从而实现了代码的灵活性和可扩展性。简单来说，多态意味着一个方法可以根据接收到的不同对象的类型来执行不同的行为。 Why 使用多态可以使代码更加灵活和可扩展。通过多态，我们可以在不改变原有代码的基础上，新增或修改对象的行为。这种灵活性使得代码更易于维护和扩展，并且提高了代码的可复用性。 How 在Golang中，多态可以通过接口来实现。接口是一种抽象类型，它定义了一组方法的集合。如果一个对象实现了接口所定义的所有方法，那么该对象就可以被视为该接口类型的实例。通过这种方式，我们可以将不同类型的对象视为相同的接口类型，从而实现多态的效果。 package main import \"fmt\" type Shape interface { Area() float64 } type Rectangle struct { width float64 height float64 } func (r Rectangle) Area() float64 { return r.width * r.height } type Circle struct { radius float64 } func (c Circle) Area() float64 { return 3.14 * c.radius * c.radius } func GetArea(s Shape) float64 { return s.Area() } func main() { r := Rectangle{width: 5, height: 3} c := Circle{radius: 4} fmt.Println(\"Rectangle area:\", GetArea(r)) fmt.Println(\"Circle area:\", GetArea(c)) } ","date":"2023-10-30","objectID":"/oop_post/:1:0","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"封装 封装是面向对象编程中的一种重要概念，它指的是将数据和对数据的操作封装在一起，形成一个独立的单元。在Golang中，封装通过访问控制来实现，即使用大小写字母来决定成员的可见性。 What 封装是将数据和对数据的操作封装在一起，形成一个单独的实体。在Golang中，封装通过使用大小写字母来决定成员的可见性。小写字母开头的标识符为私有成员，只能在当前包内访问；大写字母开头的标识符为公共成员，可以在任何包中访问。 Why 封装的主要目的是将数据隐藏起来，防止外部直接访问和修改。通过封装，可以实现对数据的保护，避免数据被意外修改或滥用。同时，封装还可以隐藏实现细节，提高代码的安全性和可维护性。 How 可以通过结构体和方法来实现封装。结构体是一种自定义数据类型，可以将不同类型的数据封装在一起。方法是与结构体关联的函数，用于对结构体的操作和行为进行封装。 package main import ( \"fmt\" ) type Person struct { name string age int gender string } func (p *Person) SetName(name string) { p.name = name } func (p *Person) GetName() string { return p.name } func main() { p := Person{ name: \"Alice\", age: 20, gender: \"Female\", } fmt.Println(p.GetName()) // 输出：Alice p.SetName(\"Bob\") fmt.Println(p.GetName()) // 输出：Bob } ","date":"2023-10-30","objectID":"/oop_post/:2:0","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"继承 ","date":"2023-10-30","objectID":"/oop_post/:3:0","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"why 继承的特点是可以在在原来的类的属性基础上增加新的属性。 把通用型的代码同一编写在一个基类中 ，在子类中添加新的属性。 可以重用前期项目中经过验证和检查的bug少的类，不会破坏原有的代码架构。 ","date":"2023-10-30","objectID":"/oop_post/:3:1","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"继承规则 在派生类没有改写基类的成员方法时，相应的成员方法被继承。 派生类可以直接调用基类的成员方法，譬如基类有个成员方法为Base.Func()，那么Derived.Func()等同于Derived.Base.Func() 如果派生类的成员方法名与基类的成员方法名相同，那么基类方法将被覆盖或叫隐藏。比如基类和派生类都有成员方法Func()，那么Derived.Func()将只能调用派生类的Func()方法，如果要调用基类版本，可以通过Derived.Base.Func()来调用。 package main import \"fmt\" type Base struct { BaseName string } func (b *Base) PrintName() { fmt.Println(b.BaseName) } type Derived struct { DerivedName string Base } func (d *Derived) PrintName() { fmt.Println(d.DerivedName) } func main() { d := \u0026Derived{} d.BaseName = \"BaseStruct\" d.DerivedName = \"DerivedStruct\" d.Base.PrintName() // BaseStruct d.PrintName() // DerivedStruct } ","date":"2023-10-30","objectID":"/oop_post/:3:2","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"总结 在 go 语言中，type name struct{} 结构体，相当于其他语言中的 class 类的概念。 在其他语言中，方法是直接写在在 类 里面的，而在 go 语言中，我们对于该结构体，如果存在方法，是以 func (结构体名) 方法名{}，即 func(c Cat) sleep{} 的方式来声明方法。 ","date":"2023-10-30","objectID":"/oop_post/:4:0","tags":["Hugo"],"title":"OOP in GO","uri":"/oop_post/"},{"categories":["Learning"],"content":"GORM","date":"2023-10-22","objectID":"/first_post/","tags":["Hugo"],"title":"GORM学习总结","uri":"/first_post/"},{"categories":["Learning"],"content":"ORM Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说，定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。 GORM（Go Object Relational Mapping）用于将Go应用程序中的结构体与关系型数据库之间进行映射，从而简化了数据库操作。它提供了一种便捷的方式来执行常见的数据库操作，如创建、读取、更新和删除（CRUD），以及复杂的查询和关联操作。 声明模型 type User struct { ID uint Name string Age int } 使用声明模型创建数据库表 db.AutoMigrate(\u0026User{}) 如果模型是动态模型，可使用原生SQL创建数据库表。 db.Exec() CREATE 传入数据的指针 newUser := User{Name: \"John\", Age: 30} db.Create(\u0026newUser) 根据Map创建 db.Model(\u0026User{}).Create(map[string]interface{}{ \"Name\": \"jinzhu\", \"Age\": 18, }) db.Model(\u0026User{}).Create([]map[string]interface{}{ {\"Name\": \"jinzhu_1\", \"Age\": 18}, {\"Name\": \"jinzhu_2\", \"Age\": 20}, }) QUERY 通过主键提取记录 var user User db.First(\u0026user, 1) 提取所有记录 var users []User db.Find(\u0026users) 按条件查询 db.Where(\"Age \u003e ?\", 25).Find(\u0026users) db.Where(\"Name LIKE ?\", \"%John%\").Find(\u0026users) 查询名字中包含John的用户 UPDATE db.Model(\u0026user).Update(\"Age\", 31) 更新多列 db.Model(\u0026user).Updates(User{Name: \"hello\", Age: 18, Active: false}) db.Model(\u0026user).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) 使用 struct 更新时，GORM 只更新非零字段。需要使用 map 来更新，或使用 Select 来指定要更新的字段。 DELETE db.Delete(\u0026user) db.Where(\"name = ?\", \"jinzhu\").Delete(\u0026user) 根据主键批量删除 db.Delete(\u0026users, []int{1,2,3}) Sorting \u0026 Limiting db.Order(\"Age desc\").Limit(10).Find(\u0026users) 关联 type User struct { gorm.Model Name string CompanyRefer int Company Company `gorm:\"foreignKey:CompanyRefer;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type Company struct { ID int Name string } Transactions tx := db.Begin() if err := tx.Create(\u0026User{Name: \"Alice\"}).Error; err != nil { tx.Rollback() } else { tx.Commit() } 使用tx而不能使用db，否则无效。 Tips 初始化指针，防止指针为空。 var city = \u0026entity.City{} 检查是否存在、不存在则创建，要考虑全面。 if errors.Is(result.Error, gorm.ErrRecordNotFound) || city == nil { tx := data.DB.Create(\u0026jsonCity) } ","date":"2023-10-22","objectID":"/first_post/:0:0","tags":["Hugo"],"title":"GORM学习总结","uri":"/first_post/"}]